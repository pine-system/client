/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class android_app_smdt_pine_hardware_IICUtil */
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/i2c.h>
#include <assert.h>
#include <errno.h>
#include <cstdio>
#include <malloc.h>

#ifndef _Included_android_app_smdt_pine_hardware_IICUtil
#define _Included_android_app_smdt_pine_hardware_IICUtil
#ifdef __cplusplus
extern "C" {
#endif
#undef android_app_smdt_pine_hardware_IICUtil_Debug
#define android_app_smdt_pine_hardware_IICUtil_Debug 1L

#define I2C_RETRIES 0x0701
#define I2C_TIMEOUT 0x0702
#define I2C_RDWR 0x0707
struct i2c_rdwr_data{
    struct i2c_msg __user *msgs;
    __u32 nmsgs;
};
struct i2c_rdwr_data *queue;
/**
 *
 * @param dev i2c path
 * @param buf buffer of data is read from i2c device
 * @param i2cDev i2c device slave addr
 * @param regAddr i2c device regulator addr
 * @param len data count;
 * @return
 */
int i2c_read(char *dev,unsigned char *buf,unsigned int i2cDev,unsigned int regAddr,int len){
    struct i2c_msg *msgs;
    int ret;
    int fd = open(dev,O_RDWR);
    if(fd < 0){
        printf("Open the device[%s] failed.\n",dev);
        return 0;
    }
    queue = (struct i2c_rdwr_data *)malloc(sizeof(struct i2c_rdwr_data));
    if(!queue){
        printf("no enough space for queue alloc\n");
        close(fd);
        return 0;
    }
    queue->nmsgs = 2;
    msgs = (struct i2c_msg*)malloc(queue->nmsgs * sizeof(struct i2c_msg));
    if(!msgs){
        printf("no enough space for msg failed.\n");
        goto I2C_MSG_SPACE_FAILED;
    }
    queue->msgs = msgs;
    ioctl(fd,I2C_RETRIES,5);
    ioctl(fd,I2C_TIMEOUT,5);

    msgs->addr = i2cDev;
    msgs->flags = !I2C_M_RD;
    msgs->len = sizeof(regAddr);
    msgs->buf = (unsigned char*)&regAddr;
    msgs ++;
    msgs->addr = i2cDev;
    msgs->flags = I2C_M_RD;
    msgs->len = len;
    msgs->buf = buf;
    ret = ioctl(fd,I2C_RDWR,(unsigned long)queue);
    if(ret < 0){
        printf("Error i2c rw ioctl with error code:%d\n",ret);
        goto I2C_RD_ERROR;
    }
    close(fd);
    return 0;
    I2C_RD_ERROR:
        free(msgs);
    I2C_MSG_SPACE_FAILED:
        free(queue);
    QUEUE_SPACE_FAILED:
        close(fd);
     return -1;
}

int i2c_write(char *dev,unsigned char *buf,unsigned int i2cDev,unsigned int regAddr,int len){
    struct i2c_msg *msgs;
    int ret;
    int fd = open(dev,O_RDWR);
    if(fd < 0){
        printf("Open the device[%s] failed.\n",dev);
        return 0;
    }
    queue = (struct i2c_rdwr_data *)malloc(sizeof(struct i2c_rdwr_data));
    if(!queue){
        printf("no enough space for queue alloc\n");
        close(fd);
        return 0;
    }
    queue->nmsgs = 1;
    msgs = (struct i2c_msg*)malloc(queue->nmsgs * sizeof(struct i2c_msg));
    if(!msgs){
        printf("no enough space for msg failed.\n");
        goto I2C_MSG_SPACE_FAILED;
    }
    queue->msgs = msgs;
    ioctl(fd,I2C_RETRIES,5);
    ioctl(fd,I2C_TIMEOUT,5);

    msgs->addr = i2cDev;
    msgs->flags = !I2C_M_RD;
    msgs->len = len + 1;
    msgs->buf = (unsigned char*)&regAddr;
    ret = ioctl(fd,I2C_RDWR,(unsigned long)queue);
    if(ret < 0){
        printf("Error i2c rw ioctl with error code:%d\n",ret);
        goto I2C_WR_ERROR;
    }
    close(fd);
    return 0;
    I2C_WR_ERROR:
    free(msgs);
    I2C_MSG_SPACE_FAILED:
    free(queue);
    QUEUE_SPACE_FAILED:
    close(fd);
    return -1;
}
/*
 * Class:     android_app_smdt_pine_hardware_IICUtil
 * Method:    open
 * Signature: ()Ljava/io/FileDescriptor;
 */
JNIEXPORT jobject JNICALL Java_android_app_smdt_pine_hardware_IICUtil_open
  (JNIEnv *env, jclass thiz,jstring i2cDev){
  int fd;
  int ret = 0;

  //openning device
  jboolean isCopy;
  const char *i2c_path = env->GetStringUTFChars(i2cDev,&isCopy);
  fd = open(i2c_path,O_RDWR);
  env->ReleaseStringUTFChars(i2cDev,i2c_path);
  if(fd < 0){
      return NULL;
  }
  jclass mFileDescriptor = env->FindClass("java/io/FileDescriptor");
  jmethodID methodFileDescriptor = env->GetMethodID(mFileDescriptor,"<init>","()V");
  jfieldID descriptorID = env->GetFieldID(mFileDescriptor,"descriptor","I");
  jobject FileDescriptor = env->NewObject(mFileDescriptor,methodFileDescriptor);
  env->SetIntField(FileDescriptor,descriptorID,(jint)fd);
  return FileDescriptor;
}

/*
 * Class:     android_app_smdt_pine_hardware_IICUtil
 * Method:    close
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_android_app_smdt_pine_hardware_IICUtil_close
  (JNIEnv *env, jclass thiz){
    jclass IICUtil = env->GetObjectClass(thiz);
    jclass mFileDescriptor = env->FindClass("java/io/FileDescriptor");
    jfieldID mFdID = env->GetFieldID(IICUtil,"mFd","Ljava/io/FileDescriptor");
    jfieldID descriptorID =  env->GetFieldID(mFileDescriptor,"descriptor","I");
    jobject mFd = env->GetObjectField(thiz,mFdID);
    jint descriptor = env->GetIntField(mFd,descriptorID);
    close(descriptor);
}

#ifdef __cplusplus
}
#endif
#endif
